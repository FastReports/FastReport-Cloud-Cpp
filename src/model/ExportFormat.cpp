/**
 * FastReport Cloud
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ExportFormat.h"

namespace fastreport {
namespace cloud {
namespace models {


namespace
{
using EnumUnderlyingType = utility::string_t;

ExportFormat::eExportFormat toEnum(const EnumUnderlyingType& val)
{
    if (val == utility::conversions::to_string_t(U("Pdf")))
        return ExportFormat::eExportFormat::ExportFormat_PDF;
    if (val == utility::conversions::to_string_t(U("Html")))
        return ExportFormat::eExportFormat::ExportFormat_HTML;
    if (val == utility::conversions::to_string_t(U("Mht")))
        return ExportFormat::eExportFormat::ExportFormat_MHT;
    if (val == utility::conversions::to_string_t(U("Image")))
        return ExportFormat::eExportFormat::ExportFormat_IMAGE;
    if (val == utility::conversions::to_string_t(U("Biff8")))
        return ExportFormat::eExportFormat::ExportFormat_BIFF8;
    if (val == utility::conversions::to_string_t(U("Csv")))
        return ExportFormat::eExportFormat::ExportFormat_CSV;
    if (val == utility::conversions::to_string_t(U("Dbf")))
        return ExportFormat::eExportFormat::ExportFormat_DBF;
    if (val == utility::conversions::to_string_t(U("Json")))
        return ExportFormat::eExportFormat::ExportFormat_JSON;
    if (val == utility::conversions::to_string_t(U("LaTeX")))
        return ExportFormat::eExportFormat::ExportFormat_LATEX;
    if (val == utility::conversions::to_string_t(U("Odt")))
        return ExportFormat::eExportFormat::ExportFormat_ODT;
    if (val == utility::conversions::to_string_t(U("Ods")))
        return ExportFormat::eExportFormat::ExportFormat_ODS;
    if (val == utility::conversions::to_string_t(U("Docx")))
        return ExportFormat::eExportFormat::ExportFormat_DOCX;
    if (val == utility::conversions::to_string_t(U("Pptx")))
        return ExportFormat::eExportFormat::ExportFormat_PPTX;
    if (val == utility::conversions::to_string_t(U("Xlsx")))
        return ExportFormat::eExportFormat::ExportFormat_XLSX;
    if (val == utility::conversions::to_string_t(U("Xps")))
        return ExportFormat::eExportFormat::ExportFormat_XPS;
    if (val == utility::conversions::to_string_t(U("Ppml")))
        return ExportFormat::eExportFormat::ExportFormat_PPML;
    if (val == utility::conversions::to_string_t(U("PS")))
        return ExportFormat::eExportFormat::ExportFormat_PS;
    if (val == utility::conversions::to_string_t(U("Richtext")))
        return ExportFormat::eExportFormat::ExportFormat_RICHTEXT;
    if (val == utility::conversions::to_string_t(U("Svg")))
        return ExportFormat::eExportFormat::ExportFormat_SVG;
    if (val == utility::conversions::to_string_t(U("Text")))
        return ExportFormat::eExportFormat::ExportFormat_TEXT;
    if (val == utility::conversions::to_string_t(U("Xaml")))
        return ExportFormat::eExportFormat::ExportFormat_XAML;
    if (val == utility::conversions::to_string_t(U("Xml")))
        return ExportFormat::eExportFormat::ExportFormat_XML;
    if (val == utility::conversions::to_string_t(U("Zpl")))
        return ExportFormat::eExportFormat::ExportFormat_ZPL;
    return {};
}

EnumUnderlyingType fromEnum(ExportFormat::eExportFormat e)
{
    switch (e)
    {
    case ExportFormat::eExportFormat::ExportFormat_PDF:
        return U("Pdf");
    case ExportFormat::eExportFormat::ExportFormat_HTML:
        return U("Html");
    case ExportFormat::eExportFormat::ExportFormat_MHT:
        return U("Mht");
    case ExportFormat::eExportFormat::ExportFormat_IMAGE:
        return U("Image");
    case ExportFormat::eExportFormat::ExportFormat_BIFF8:
        return U("Biff8");
    case ExportFormat::eExportFormat::ExportFormat_CSV:
        return U("Csv");
    case ExportFormat::eExportFormat::ExportFormat_DBF:
        return U("Dbf");
    case ExportFormat::eExportFormat::ExportFormat_JSON:
        return U("Json");
    case ExportFormat::eExportFormat::ExportFormat_LATEX:
        return U("LaTeX");
    case ExportFormat::eExportFormat::ExportFormat_ODT:
        return U("Odt");
    case ExportFormat::eExportFormat::ExportFormat_ODS:
        return U("Ods");
    case ExportFormat::eExportFormat::ExportFormat_DOCX:
        return U("Docx");
    case ExportFormat::eExportFormat::ExportFormat_PPTX:
        return U("Pptx");
    case ExportFormat::eExportFormat::ExportFormat_XLSX:
        return U("Xlsx");
    case ExportFormat::eExportFormat::ExportFormat_XPS:
        return U("Xps");
    case ExportFormat::eExportFormat::ExportFormat_PPML:
        return U("Ppml");
    case ExportFormat::eExportFormat::ExportFormat_PS:
        return U("PS");
    case ExportFormat::eExportFormat::ExportFormat_RICHTEXT:
        return U("Richtext");
    case ExportFormat::eExportFormat::ExportFormat_SVG:
        return U("Svg");
    case ExportFormat::eExportFormat::ExportFormat_TEXT:
        return U("Text");
    case ExportFormat::eExportFormat::ExportFormat_XAML:
        return U("Xaml");
    case ExportFormat::eExportFormat::ExportFormat_XML:
        return U("Xml");
    case ExportFormat::eExportFormat::ExportFormat_ZPL:
        return U("Zpl");
    default:
        break;
    }
    return {};
}
}

ExportFormat::ExportFormat()
{
}

ExportFormat::~ExportFormat()
{
}

void ExportFormat::validate()
{
    // TODO: implement validation
}

web::json::value ExportFormat::toJson() const
{
    auto val = fromEnum(m_value);
    return web::json::value(val);
}

bool ExportFormat::fromJson(const web::json::value& val)
{
    m_value = toEnum(val.as_string());
    return true;
}

void ExportFormat::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if (!namePrefix.empty() && namePrefix.back() != U('.'))
    {
        namePrefix.push_back(U('.'));
    }

    auto e = fromEnum(m_value);
    multipart->add(ModelBase::toHttpContent(namePrefix, e));
}

bool ExportFormat::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if (!namePrefix.empty() && namePrefix.back() != U('.'))
    {
        namePrefix.push_back(U('.'));
    }
    {
        EnumUnderlyingType e;
        ok = ModelBase::fromHttpContent(multipart->getContent(namePrefix), e);
        if (ok)
        {
            auto v = toEnum(e);
            setValue(v);
        }
    }
    return ok;
}

ExportFormat::eExportFormat ExportFormat::getValue() const
{
   return m_value;
}

void ExportFormat::setValue(ExportFormat::eExportFormat const value)
{
   m_value = value;
}


}
}
}



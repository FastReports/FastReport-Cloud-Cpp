/**
 * FastReport Cloud
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.1.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "TimePeriodType.h"

namespace fastreport {
namespace cloud {
namespace models {



TimePeriodType::TimePeriodType()
{
}

TimePeriodType::~TimePeriodType()
{
}

void TimePeriodType::validate()
{
    // TODO: implement validation
}

web::json::value TimePeriodType::toJson() const
{
    web::json::value val = web::json::value::object();

    
    if (m_value == eTimePeriodType::TimePeriodType_SECOND) val = web::json::value::string(U(Second));
    if (m_value == eTimePeriodType::TimePeriodType_MINUTE) val = web::json::value::string(U(Minute));
    if (m_value == eTimePeriodType::TimePeriodType_HOUR) val = web::json::value::string(U(Hour));
    if (m_value == eTimePeriodType::TimePeriodType_DAY) val = web::json::value::string(U(Day));
    if (m_value == eTimePeriodType::TimePeriodType_WEEK) val = web::json::value::string(U(Week));
    if (m_value == eTimePeriodType::TimePeriodType_MONTH) val = web::json::value::string(U(Month));
    if (m_value == eTimePeriodType::TimePeriodType_YEAR) val = web::json::value::string(U(Year));

    return val;
}

bool TimePeriodType::fromJson(const web::json::value& val)
{
    auto s = val.as_string();

    
    if (s == utility::conversions::to_string_t(Second)) m_value = eTimePeriodType::TimePeriodType_SECOND;
    if (s == utility::conversions::to_string_t(Minute)) m_value = eTimePeriodType::TimePeriodType_MINUTE;
    if (s == utility::conversions::to_string_t(Hour)) m_value = eTimePeriodType::TimePeriodType_HOUR;
    if (s == utility::conversions::to_string_t(Day)) m_value = eTimePeriodType::TimePeriodType_DAY;
    if (s == utility::conversions::to_string_t(Week)) m_value = eTimePeriodType::TimePeriodType_WEEK;
    if (s == utility::conversions::to_string_t(Month)) m_value = eTimePeriodType::TimePeriodType_MONTH;
    if (s == utility::conversions::to_string_t(Year)) m_value = eTimePeriodType::TimePeriodType_YEAR;
    return true;
}

void TimePeriodType::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    utility::string_t s;

    
    if (m_value == eTimePeriodType::TimePeriodType_SECOND) s = utility::conversions::to_string_t(Second);
    if (m_value == eTimePeriodType::TimePeriodType_MINUTE) s = utility::conversions::to_string_t(Minute);
    if (m_value == eTimePeriodType::TimePeriodType_HOUR) s = utility::conversions::to_string_t(Hour);
    if (m_value == eTimePeriodType::TimePeriodType_DAY) s = utility::conversions::to_string_t(Day);
    if (m_value == eTimePeriodType::TimePeriodType_WEEK) s = utility::conversions::to_string_t(Week);
    if (m_value == eTimePeriodType::TimePeriodType_MONTH) s = utility::conversions::to_string_t(Month);
    if (m_value == eTimePeriodType::TimePeriodType_YEAR) s = utility::conversions::to_string_t(Year);

    multipart->add(ModelBase::toHttpContent(namePrefix, s));
}

bool TimePeriodType::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    {
        utility::string_t s;
        ok = ModelBase::fromHttpContent(multipart->getContent(namePrefix), s);
        eTimePeriodType v;

        
        if (s == utility::conversions::to_string_t(Second)) v = eTimePeriodType::TimePeriodType_SECOND;
        if (s == utility::conversions::to_string_t(Minute)) v = eTimePeriodType::TimePeriodType_MINUTE;
        if (s == utility::conversions::to_string_t(Hour)) v = eTimePeriodType::TimePeriodType_HOUR;
        if (s == utility::conversions::to_string_t(Day)) v = eTimePeriodType::TimePeriodType_DAY;
        if (s == utility::conversions::to_string_t(Week)) v = eTimePeriodType::TimePeriodType_WEEK;
        if (s == utility::conversions::to_string_t(Month)) v = eTimePeriodType::TimePeriodType_MONTH;
        if (s == utility::conversions::to_string_t(Year)) v = eTimePeriodType::TimePeriodType_YEAR;

        setValue(v);
    }
    return ok;
}

TimePeriodType::eTimePeriodType TimePeriodType::getValue() const
{
   return m_value;
}

void TimePeriodType::setValue(TimePeriodType::eTimePeriodType const value)
{
   m_value = value;
}


}
}
}


